\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage[french]{babel}
\usepackage{comment}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{xcolor}

\usepackage{geometry} % Mise en page
\geometry{a4paper, margin=2.5cm}

\usepackage{minted} % Code
\usemintedstyle{vs}

\usepackage{listings} % Pseudo-code
\usepackage{lmodern} % Mots clés en gras dans le code
\lstdefinestyle{pseudocode}{
    backgroundcolor=\color{white},
    numberstyle=\tiny,
    basicstyle=\ttfamily\small\color{blue},
    keywordstyle=\bfseries,
    morekeywords={Fonction, Pour, Si, Renvoyer, Tant},
    breaklines=true,
    keepspaces=true,
    numbers=left,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4
}
\lstset{style=pseudocode}
\lstset{ % Accents
  literate=%
    {é}{{\'e}}1
    {è}{{\`e}}1
    {ê}{{\^e}}1
    {à}{{\`a}}1
}

\usepackage{tikz} % Figures
\tikzstyle{node} = [circle, draw, minimum size=18pt, thick]
\tikzstyle{selected node} = [circle, fill=red!60]
\tikzstyle{edge} = [draw, line width=2pt, -]
\tikzstyle{selected edge} = [draw, line width=2pt, -, red!80]

\newtheorem*{theorem}{Théorème} % Théorèmes
\newtheorem*{definition}{Définition}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  filecolor=magenta,
  urlcolor=magenta
}


\title{Algorithmes et structures de données}
\author{Adrien Vannson}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Graphes}
Soit \(G=(V,E)\) un graphe. On posera \(N = Card(V)\) et \(M=Card(E)\).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Plus courts chemins %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Plus courts chemins}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Floyd-Warshall %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Floyd-Warshall}

L'algorithme de Floyd-Warshall permet de calculer la longueur du plus court chemin entre chaque paire de noeuds d'un graphe \(G\) orienté et pondéré avec une complexité en \(\Theta(N^3)\). Les pondérations peuvent éventuellement être négatives, mais il ne doit pas exister de cycle négatif dans \(G\).

\begin{lstlisting}
On initialise dist comme étant la matrice d'adjacence du graphe
Pour chaque noeud p:
  Pour chaque noeud d:
    Pour chaque noeud f:
      dist[d][f] = min(
        dist[d][p] + dist[p][f],
        dist[d][f]
      )
\end{lstlisting}

\begin{proof}
La correction de l'algorithme est assurée par l'invariant de boucle suivant, vérifié au début de chaque itération de la boucle principale : pour toute paire de noeuds d'indices respectifs \(d\) et \(f\), \(dist[d][f]\) est la longueur du plus court chemin du noeud d'indice \(d\) vers le noeud d'indice \(f\) n'utilisant comme noeuds intermédiaires que des noeuds d'indice dans \( [\![0, p-1]\!] \).
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Arbre du DFS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Arbre du DFS}
Il est possible de représenter un graphe orienté en mettant en avant les différentes propriétés de ses arcs pouvant être rencontrées lors d'un parcours en profondeur, ce qui peut par exemple aider à adapter l'algorithme du DFS à différents problèmes.
Pour cela, on effectue un parcours en profondeur du graphe, puis on représente le graphe selon l'arbre des appels de la fonction récursive.

\begin{figure}[h]
  \label{arbre-dfs}
  \centering
  \caption{Arbre du DFS}
    \begin{tikzpicture}[scale=1.4]
      \node[node] (0) at (1,3) {};
      \node[node] (1) at (0,2) {};
      \node[node] (2) at (2,2) {};
      \node[node] (3) at (1,1) {};
      \node[node] (4) at (3,1) {};
      \node[node] (5) at (0,0) {};
      \node[node] (6) at (1,0) {};
      \node[node] (7) at (2,0) {};

      \draw[edge, ->] (0) to (1);
      \draw[edge, ->] (0) to (2);
      \draw[edge, ->] (2) to (3);
      \draw[edge, ->] (2) to (4);
      \draw[edge, ->] (3) to (5);
      \draw[edge, ->] (3) to (6);
      \draw[edge, ->] (3) to (7);

      \draw[edge, ->, red] (5) to [bend left] (2);
      \draw[edge, ->, green] (0) to [bend left] (4);
      \draw[edge, ->, blue] (4) to (3);
      \draw[edge, ->, blue] (4) to (7);
    \end{tikzpicture}
\end{figure}

Les arcs peuvent être classés en quatre catégories :
\begin{itemize}
  \item[\LARGE\textbf\textrightarrow] les \textit{arcs de découverte} pointent vers un noeud n'ayant pas encore été parcouru
  \item[\color{red} \LARGE\textbf\textrightarrow] les \textit{arcs arrières} pointent vers un noeud en cours de parcours
  \item[\color{green} \LARGE\textbf\textrightarrow] les \textit{arcs avants} pointent vers un noeud parcouru qui est un descendant du noeud actuel dans l'arbre d'appels
  \item[\color{blue} \LARGE\textbf\textrightarrow] les \textit{arcs transverses} pointent vers un noeud parcouru qui n'est pas un descendant du noeud actuel dans l'arbre d'appels
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Composantes fortement connexes %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Composantes fortement connexes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Algorithme de Kosaraju  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Algorithme de Kosaraju}
L'algorithme de Kosaraju permet de calculer les composantes fortement connexes d'un graphe orienté. Pour cela, il effectue successivement deux DFS. Le premier permet de trouver un parcours suffixe du graphe, c'est-à-dire un parcours suffixe de l'arbre des appels du DFS. Le deuxième est effectué sur le graphe transposé \(G^\top\) (graphe obtenu en inversant les arcs de \(G\)), en découvrant les noeuds dans l'ordre inverse du parcours suffixe. Il permet de déterminer les composantes fortement connexes du graphe.

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/graphs/algorithms/kosaraju.hpp}{Implémentation}
\begin{lstlisting}
Trouver un parcours suffixe du graphe
Pour chaque noeud v dans l'ordre inverse du parcours suffixe :
    Si v n'a pas encore été visité :
        Trouver l'ensemble des noeuds non-visités ayant accès à v
        Cet ensemble est la composante fortement connexe contenant v
        Marquer tous ses noeuds comme visités
\end{lstlisting}

\begin{proof}
  Montrons que l'ordre de parcours obtenu avec le premier DFS permet effectivement de trouver les composantes fortement connexes lors du deuxième DFS. Soit \(v\) un noeud sur lequel débute un parcours du deuxième DFS.
  \begin{itemize}
    \item Soit \(u\) un noeud de la composante fortement connexe à laquelle \(v\) appartient. Il existe un chemin de \(v\) vers \(u\) dans \(G^\top\). De plus, \(v\) est le premier noeud de sa composante fortement connexe à être rencontré, donc aucun des noeuds permettant de se rendre de \(v\) vers \(u\) n'a été initialement visité. Ainsi, \(u\) sera détecté lors du parcours.
    \item Soit \(u\) un noeud parcouru lors de l'appel du deuxième DFS depuis le noeud \(v\). Montrons que \(u\) appartient à la composante fortement connexe contenant \(v\).
      \begin{itemize}
        \item Il existe un chemin de \(v\) vers \(u\) dans \(G^\top\), donc il existe un chemin de \(u\) vers \(v\) dans \(G\).
        \item On suppose qu'il n'existe pas de chemin de \(v\) vers \(u\) dans \(G\). Le point précédent assure que \(v\) apparaît avant \(u\) dans le parcours suffixe de \(G\), donc que \(u\) a déjà été parcouru lorsque le parcours de \(v\) commence. Cela est absurde car \(u\) devrait être parcouru à nouveau lors de l'exploration depuis \(v\).
      \end{itemize}
  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Algorithme de Tarjan  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Algorithme de Tarjan}
L'algorithme de Tarjan permet de calculer les composantes fortement connexes d'un graphe orienté \(G=(V,E)\). Il effectue un parcours en profondeur du graphe, on utilisera donc la représentation graphique décrite précédemment qui est adaptée à cette situation. \\
On définit tout d'abord la racine d'une composante fortement connexe comme étant le premier noeud de la composante rencontré lors du parcours du graphe. Elles sont représentés en jaune sur le schéma. On remarque qu'une composante fortement connexe est un sous-arbre de l'arbre des appels du DFS enraciné sur la racine de la composante, privé des éventuels sous-arbres correspondant à d'autres composantes. Pour trouver les composantes fortement connexes, il suffit donc de trouver l'ensemble de leurs racines. \\
On effectue un DFS sur le graphe, en maintenant à jour :
\begin{itemize}
  \item Des identifiants pour chacun des noeuds : ils sont données par ordre croissant au fur et à mesure du parcours
  \item Une pile contenant les noeuds dont la composante n'a pas encore été parcourue complètement, ajoutés dans leur ordre de parcours
  \item L'état de chaque noeud, parmi les états suivants :
    \begin{itemize}
      \item À visiter : le noeud est encore inconnu
      \item Dans la pile : le noeud a été découvert, mais sa composante fortement connexe n'est pas encore complètement connue
      \item Visité : le parcours du noeud est terminé, et sa composante fortement connexe est complètement connue
    \end{itemize}
\end{itemize}
La fonction \lstinline|parcourir| renvoie le plus petit identifiant d'un noeud présent dans la pile et accessible directement depuis le sous-arbre enraciné sur le noeud d'appel, ou éventuellement \(+\infty\) si aucun noeud ne convient.

\begin{figure}[h]
  \label{algorithme-tarjan}
  \centering
  \caption{Exemple}
  \begin{tikzpicture}[scale=1.6]
    \node[node, fill=yellow] (01) at (1,4) {1};
    \node[node, fill=yellow] (02) at (0,3) {2};
    \node[node] (03) at (0,2) {3};
    \node[node, fill=yellow] (04) at (1,3) {4};
    \node[node] (05) at (1,2) {5};
    \node[node] (06) at (1,1) {6};
    \node[node] (07) at (1,0) {7};
    \node[node] (08) at (2,2) {8};
    \node[node] (09) at (2,1) {9};
    \node[node] (10) at (2,3) {10};
    \node[node] (11) at (3,2) {11};

    \foreach \u / \v in {01/02, 01/04, 01/10, 02/03, 04/05, 05/06, 06/07, 04/08, 08/09, 10/11}
      \draw[edge, ->] (\u) to (\v);

    \draw[edge, ->, red] (03) to [bend left] (02);
    \draw[edge, ->, red] (07) to [bend left] (05);
    \draw[edge, ->, red] (06) to [bend right] (04);
    \draw[edge, ->, red] (11) to [bend left] (01);
    \draw[edge, ->, green] (01) to [bend right] (05);
    \draw[edge, ->, blue] (05) to (03);
    \draw[edge, ->, blue] (09) to (07);
  \end{tikzpicture}
\end{figure}

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/graphs/algorithms/tarjan.hpp}{Implémentation}
\begin{lstlisting}
Fonction parcourir (noeud):
    Donner un identifiant au noeud actuel
    Ajouter le noeud à la pile et mettre à jour son état

    idMinAccessible = idNoeud

    Pour chaque voisin:
        Si le voisin est dans la pile:
            idMinAccessible = min(idVoisin, idMinAccessible)
        Si le voisin n'a pas encore été visité:
            idMinAccessible = min(parcourir(voisin), idMinAccessible)

    Si idMinAccessible == idNoeud:
        La composante fortement connexe du noeud est composée des noeuds
          de la pile à partir du noeud actuel
        Enlever ces noeuds de la pile, et les marquer comme visités
        Renvoyer +oo

    Renvoyer idMinAccessible

Pour chaque noeud du graphe:
    Si le noeud est inconnu:
        Appeler la fonction parcourir sur ce noeud
\end{lstlisting}

Montrons que la fonction parcourir a le comportement attendu. On suppose que, lors d'un appel à la fonction parcourir, la boucle sur tous les voisins vient de se terminer.
\begin{itemize}
  \item Si idMinAccessible vaut l'identifiant du noeud, alors il est impossible de sortir du sous-arbre depuis celui-ci, sauf éventuellement vers une composante fortement connexe déjà complète. Le noeud est donc une racine, et la composante fortement connexe correspondante est composée de l'ensemble des noeuds au-dessus du noeud actuel dans la pile. On ajoute la composante à celles déjà détectées, et on continue l'exploration.
  \item On suppose à présent que idMinAccessible est strictement inférieur à l'identifiant du noeud. Le noeud correspondant appartient à une composante fortement connexe dont la racine est toujours en cours de visite (sinon, la composante aurait été trouvée). C'est donc un noeud ascendant du noeud actuel, et il est accessible depuis celui-ci. Ainsi, le noeud actuel n'est pas une racine. On renvoie la valeur demandée et on continue le parcours.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Flots %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Flots}
    \subsubsection{Définitions}

Soit \(G=(V,E)\) un graphe orienté et \((s,p)\) deux sommets distincts de \(V\) que l'on appellera respectivement \textit{source} et \textit{puits}. On associe à chaque arc \(e \in E\) un réel positif représentant sa capacité. Pour tout \((u,v) \in V^2\), on notera \(c(u,v)\) la somme des capacités des arcs de \(u\) vers \(v\).

\begin{definition}
  \(F = (G,c,s,p)\) constitue un réseau de flot.
\end{definition}

\begin{definition}
  Un flot \(f\) est une application de \(V^2\) dans \(\mathbb{R}\) telle que :
  \begin{itemize}
    \item Pour tout \((u,v) \in V^2\), \(f(u,v) \leq c(u,v)\)
    \item Pour tout \((u,v) \in V^2\), \(f(u,v) = -f(v,u)\)
    \item Pour tout \(u \in V \setminus \{s,p\}\), \(\sum\limits_{v \in V} f(u,v) = 0\)
    \item \(\sum\limits_{v \in V} f(s,v) \geq 0\) et \(\sum\limits_{v \in V} f(p,v) \leq 0\)
  \end{itemize}
\end{definition}

\begin{definition}
  La valeur d'un flot \(f\) est \(|f| = \sum\limits_{v \in V} f(s,v)\).
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Capacités résiduelles %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Capacités résiduelles}

Pour tout \((u,v) \in V^2\), on notera \(c_f(u,v) = c(u,v) - f(u,v)\) la capacité résiduelle de \(u\) vers \(v\). Cela correspond à la capacité disponible de \(u\) vers \(v\) après l'application du flot \(f\). Le réseau résiduel correspondant à \((F,f)\) est obtenu en remplaçant dans \(F\) les capacités des arcs par leurs capacités résiduelles.

\begin{definition}
  Un chemin augmentant est un chemin de \(s\) vers \(p\) sur lequel toutes les capacités résiduelles sont strictement positives.
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Algorithme d'Edmonds-Karp %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Algorithme d'Edmonds-Karp}
L'algorithme d'Edmonds-Karp permet de calculer le flot maximal pouvant traverser un réseau avec une complexité temporelle en \(O(|V| |E|^2)\). Sa complexité est également en \(O(S)\) où \(S\) est la somme des capacités des arcs du graphe. Pour cela, il commence par considérer un flot nul qu'il améliore ensuite tant que possible ; le flot finalement obtenu étant de valeur maximale.

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/graphs/algorithms/edmonds-karp.hpp}{Implémentation}
\begin{lstlisting}
Initialiser f comme étant un flot nul
Créer le réseau résiduel correspondant à f
Tant qu'il existe un chemin augmentant dans le réseau résiduel :
    Utiliser ce chemin pour améliorer le flot
    Mettre à jour le graphe résiduel
\end{lstlisting}

La recherche d'un chemin augmentant est effectuée à l'aide d'un BFS dans le graphe résiduel.

\begin{proof} \leavevmode
  \begin{itemize}
    \item Terminaison : \(|f|\) croît strictement à chaque itération de la boucle principale, et la valeur d'un flot est majorée par la somme de la capacité des arcs. Ainsi, \textbf{lorsque les capacités sont des entiers}, l'algorithme termine. Cet argument prouve également la complexité en \(O(S)\).
    \item Correction : Lorsque l'algorithme termine, il n'existe plus de chemin augmentant, le flot obtenu est donc de valeur maximale.
    % \item Complexité : la recherche d'un chemin augmentant est effectuée à l'aide d'un BFS, sa complexité temporelle est donc en \(O(|E|)\).
  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Théorème Flot-Max / Coupe-Min %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Théorème Flot-Max / Coupe-Min}

\begin{figure}[ht]
  \centering
  \begin{minipage}{.5\textwidth}
    \centering
    \caption{Graphe \(G\), flot max}

    \begin{tikzpicture}[scale=0.03]
      \node[node][fill=green!80] (00) at (238.2, 119)     {p};
      \node[node] (01) at (164.8, 103.4)   {};
      \node[node] (02) at (182.1, 169.7)   {};
      \node[node] (03) at (286.2, 167.5)   {};
      \node[node] (04) at (211.1, 220)     {};
      \node[node] (05) at (282.5, 238.1)   {};
      \node[node] (06) at (133.5, 215.9)   {};
      \node[node][fill=orange!80] (07) at (165.5, 279.4)   {s};
      \node[node] (08) at (235.7, 291.2)   {};

      \draw[selected edge, <-] (00) -- (01);
      \draw[edge]              (00) -- (02);
      \draw[selected edge, <-] (00) -- (03);
      \draw[selected edge, <-] (01) -- (02);
      \draw[selected edge, <-] (02) -- (04);
      \draw[edge]              (03) -- (04);
      \draw[selected edge, <-] (03) -- (05);
      \draw[edge]              (04) -- (06);
      \draw[selected edge, <-] (04) -> (07);
      \draw[edge]              (04) -- (08);
      \draw[selected edge, <-] (05) -- (08);
      \draw[edge]              (06) -- (07);
      \draw[selected edge, ->] (07) -- (08);
    \end{tikzpicture}
  \end{minipage}%
  \begin{minipage}{.5\textwidth}
    \centering
    \caption{Graphe résiduel \(G'\)}

    \begin{tikzpicture}[scale=0.03]
      \node[node][fill=green!80] (00) at (238.2, 119)     {p};
      \node[node][fill=green!60] (01) at (164.8, 103.4)   {};
      \node[node][fill=green!60] (02) at (182.1, 169.7)   {};
      \node[node][fill=orange!60] (03) at (286.2, 167.5)   {};
      \node[node][fill=orange!60] (04) at (211.1, 220)     {};
      \node[node][fill=orange!60] (05) at (282.5, 238.1)   {};
      \node[node][fill=orange!60] (06) at (133.5, 215.9)   {};
      \node[node][fill=orange!80] (07) at (165.5, 279.4)   {s};
      \node[node][fill=orange!60] (08) at (235.7, 291.2)   {};

      \draw[edge, ->] (00) -- (01) node [midway, fill=white] {2};;
      \draw[edge]              (00) -- (02);
      \draw[edge, ->] (00) -- (03) node [midway, fill=white] {2};;
      \draw[edge, ->] (01) -- (02) node [midway, fill=white] {2};;
      \draw[edge, ->] (02) -- (04) node [midway, fill=white] {2};;
      \draw[edge]              (03) -- (04);
      \draw[edge, ->] (03) -- (05) node [midway, fill=white] {2};;
      \draw[edge]              (04) -- (06);
      \draw[edge, ->] (04) -> (07) node [midway, fill=white] {2};;
      \draw[edge]              (04) -- (08);
      \draw[edge, ->] (05) -- (08) node [midway, fill=white] {2};;
      \draw[edge]              (06) -- (07);
      \draw[edge, <-] (07) -- (08) node [midway, fill=white] {2};;
    \end{tikzpicture}
  \end{minipage}
\end{figure}

\begin{theorem}
Soit \(G=(V,E)\) un graphe orienté pondéré, et \(s\) et \(p\) deux sommets de \(G\). La valeur maximale d'un flot de \(s\) vers \(p\) est égale à la valeur minimale d'une coupe entre \(s\) et \(p\).
\end{theorem}
\begin{proof}\leavevmode
  \begin{itemize}
    \item Le flot max doit être réparti parmi les arcs de toute coupe, donc \( \left| FlotMax \right| \leq \left| CoupeMin \right| \)
    \item On note \(G'\) le graphe résiduel correspondant à un flot max de \(G\), \(A\) l'ensemble des noeuds accessibles depuis \(S\) dans \(G'\) et \(B\) l'ensemble des noeuds n'appartenant pas à \(A\). Il n'existe pas de chemin améliorant, donc \(p \in B\). On considère \(\mathcal{C}\) l'ensemble des arcs de \(G\) partant d'un noeud de \(A\) vers un noeud de \(B\).
    \begin{itemize}
        \item \(s \in A\), \(p \in B\) et il n'existe pas d'arc hors de \(\mathcal{C}\) d'un noeud de \(A\) vers un noeud de \(B\), donc \(\mathcal{C}\) est une coupe.
        \item Dans le graphe résiduel \(G'\), il n'existe pas d'arc de \(A\) vers \(B\), donc les arcs de \(B\) vers \(A\) ne sont pas utilisés et ceux de \(A\) vers \(B\) sont saturés. Ainsi, la somme des capacités des arcs de \(A\) vers \(B\) est égale au flot max. Or, cette somme est égale à la somme des pondérations des arcs de \(\mathcal{C}\), donc \( \left| CoupeMin \right| \leq \left| FlotMax \right| \)
    \end{itemize}
  \end{itemize}
  Finalement, \( \left| CoupeMin \right| = \left| FlotMax \right| \)
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Couplages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Couplages}
Soit \(G=(V,E)\) un graphe biparti dont on note \((X,Y)\) une partition des sommets adaptée, c'est-à-dire telle que toute arête relie un noeud de \(X\) avec un noeud de \(Y\). Un \textit{couplage} \(C\) de \(G\) est une partie de \(E\) telle que tout noeud ne soit relié qu'à au plus une arête de \(C\). Un couplage est dit \textit{maximum} si et seulement si il est de cardinal maximal. Pour la suite, les arêtes d'un graphe appartenant à un couplage seront représentées en rouge et celles n'y appartenant pas seront représentées en noir.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Chemins d'augmentation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \subsubsection{Chemins d'augmentation}

\begin{definition}
  Un chemin d'augmentation d'un graphe biparti \(G=(V,E)\) muni d'un couplage \(C\) est une suite finie \(v = (v_0, ..., v_{p-1})\) de sommets de \(V\) telle que \(v_0 \in X\), \(v_{p-1} \in Y\), les sommets \(v_0\) et \(v_{p-1}\) ne soient reliés à aucune arête de \(C\) et :
  \[
    \forall i \in [\![0,p-2]\!], \{v_i,v_{i+1}\} \in
      \left\{
        \begin{array}{ll}
          E \setminus C & \text{ si i est pair} \\
          C & \text{ si i est impair}
        \end{array}
      \right.
  \]
\end{definition}

\begin{theorem}
  Un couplage \(C\) d'un graphe biparti \(G=(V,E)\) est maximum si et seulement si il n'existe pas de chemin d'augmentation pour ce couplage.
\end{theorem}
\begin{proof}\leavevmode
  \begin{itemize}
    \item On suppose qu'il existe un chemin d'augmentation \(v = (v_0, ..., v_{p-1})\). La différence symétrique de \(C\) et de \(\{ \{v_i,v_{i+1}\}, i \in [\![0,p-2]\!] \}\) est alors un couplage de cardinal \(|C|+1\). Ainsi, s'il existe un chemin d'augmentation, le couplage n'est pas maximum.

    \item
      On suppose réciproquement qu'il n'existe pas de chemin d'augmentation. Il existe \(C_0\) un couplage maximum de \(G\). On note \(D\) la différence symétrique de \(C\) et de \(C_0\). \(C\) et \(C_0\) sont des couplages, donc chaque sommet de \(G\) est adjacent à au plus deux arêtes de \(D\). Ainsi, les arêtes de \(D\) forment des \textit{cycles} ou des \textit{chaînes} d'arêtes, par exemple :

      \begin{figure}[ht]
        \centering
        \begin{minipage}{.5\textwidth}
          \centering
          \caption{Cycle}
          \begin{tikzpicture}[scale=1.3]
            \node[node] (0) at (0,0)   {};
            \node[node] (1) at (1,0)   {};
            \node[node] (2) at (0,1)   {};
            \node[node] (3) at (1,1)   {};
            \draw[edge, red] (0) -- (1);
            \draw[edge, red] (1) -- (2);
            \draw[edge, red] (2) -- (3);
            \draw[edge, red] (3) -- (0);
          \end{tikzpicture}
        \end{minipage}%
        \begin{minipage}{.5\textwidth}
          \centering
          \caption{Chaîne}
          \begin{tikzpicture}[scale=1.3]
            \node[node] (0) at (0,0)   {};
            \node[node] (1) at (1,0)  {};
            \node[node] (2) at (0,1)  {};
            \node[node] (3) at (1,1)   {};
            \draw[edge, red] (0) -- (1);
            \draw[edge, red] (2) -- (3);
            \draw[edge, red] (3) -- (0);
          \end{tikzpicture}
        \end{minipage}
      \end{figure}

      On suppose qu'il existe une chaîne composée d'un nombre impair d'arêtes. Si les arêtes à ses extrémités sont dans \(C\), elle permet d'obtenir un chemin d'augmentation pour \(C_0\), et si les arêtes à ses extrémités sont dans \(C_0\), elle permet d'obtenir un chemin d'augmentation pour \(C\). Or, cela est absurde car il n'existe de chemin d'augmentation ni pour \(C\) (par hypothèse), ni pour \(C_0\) (il est maximum). Toutes les chaînes sont ainsi composées d'un nombre pair d'arêtes. Finalement, \(|C|=|C_0|\), donc \(C\) est maximum.

  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Géométrie %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Géométrie}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Enveloppe convexe %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Enveloppe convexe}

On considère un ensemble \(A\) de \(n\) points du plan de coordonnées \((x_i,y_i)\) dont on cherche à calculer l'enveloppe convexe. Pour cela, il suffit de calculer d'abord la partie supérieure de l'enveloppe, puis sa partie inférieure. Le calcul de la partie inférieure pourra s'effectuer de manière similaire à celui de la partie supérieure, on ne décrira donc que le calcul de la partie supérieure. On effectue un balayage des points de \(A\) par abscisses décroissantes, en maintenant sur une pile l'ensemble des points de \(A\) parcourus et appartenant à la frontière de l'enveloppe convexe actuelle. À chaque tour de boucle, on enlève de la pile les points n'appartenant plus à l'enveloppe convexe, puis on ajoute le point actuel.

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/geometry/convex-hull.hpp}{Implémentation}
\begin{lstlisting}
Créer une pile de points vide
Pour chaque point de A par abscisses décroissantes :
    Tant que le point en haut de la pile peut être supprimé :
        Le supprimer
    Ajouter le point actuel à la pile
\end{lstlisting}

L'algorithme décrit a une complexité temporelle en \(O(n \log(n) )\) car il nécessite un tri des points.



\end{document}
