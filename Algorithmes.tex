\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage[french]{babel}
\usepackage{comment}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{xcolor}

\usepackage{geometry} % Mise en page
\geometry{a4paper, margin=2.5cm, headheight=15pt}

\usepackage{fancyhdr} % En-têtes et pieds de page
\pagestyle{fancy}
\fancyhf{}
\lhead{\leftmark}
%\rhead{\rightmark}
\lfoot{Adrien Vannson}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0.5pt}

\usepackage{minted} % Code
\usemintedstyle{vs}

\usepackage{listings} % Pseudo-code
\usepackage{lmodern} % Mots clés en gras dans le code
\lstdefinestyle{pseudocode}{
    backgroundcolor=\color{white},
    numberstyle=\tiny,
    basicstyle=\ttfamily\small\color{blue},
    keywordstyle=\bfseries,
    morekeywords={Fonction, Pour, Si, Renvoyer, Tant},
    breaklines=true,
    keepspaces=true,
    numbers=left,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4
}
\lstset{style=pseudocode}
\lstset{ % Accents
  literate=%
    {é}{{\'e}}1
    {è}{{\`e}}1
    {ê}{{\^e}}1
    {à}{{\`a}}1
    {É}{{\'E}}1
    {À}{{\`A}}1
}

\usepackage{tikz} % Figures
\tikzstyle{node} = [circle, draw, minimum size=18pt, thick]
\tikzstyle{selected node} = [circle, fill=red!60]
\tikzstyle{edge} = [draw, line width=2pt, -]
\tikzstyle{selected edge} = [draw, line width=2pt, -, red!80]

\newtheorem*{theorem}{Théorème} % Théorèmes
\newtheorem*{definition}{Définition}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  filecolor=magenta,
  urlcolor=magenta
}


\title{Algorithmes et structures de données}
\author{Adrien Vannson}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Structures de données %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structures de données}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Union-Find %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Union-Find}
L'union-find est une structure de données permettant de maintenir à jour une partition d'un ensemble. Il supporte deux opérations principales :
\begin{itemize}
  \item La recherche de la composante d'un élément : à chaque élément, elle associe un représentant ne dépendant que de la composante dans laquelle il se trouve.
  \item La fusion des composantes dans lesquelles se trouvent deux éléments.
\end{itemize}
Pour cela, il utilise une structure de forêt dans laquelle chaque noeud correspond à un élément et contient deux informations :
\begin{itemize}
  \item Le père du noeud s'il n'est pas une racine, lui-même sinon.
  \item Un entier valant le nombre de noeuds du sous-arbre dont il est la racine si c'est une racine et \(0\) sinon.
\end{itemize}
Cette forêt est telle que deux éléments sont dans la même composante si et seulement si leurs noeuds correspondant appartiennent au même arbre. Le représentant associé à un noeud est alors la racine de l'arbre dans lequel celui-ci se trouve.

\begin{lstlisting}
Fonction initialiser () :
    Pour chaque noeud :
        noeud.père = noeud
        noeud.taille = 1

Fonction représentant (noeud) :
    Si noeud.père != noeud:
        noeud.père = représentant(noeud.père)
    Renvoyer noeud.père

Fonction unir (noeud1, noeud2) :
    noeud1 = représentant(noeud1)
    noeud2 = représentant(noeud2)

    Si noeud1 != noeud2 :
        Si noeud2.taille > noeud1.taille :
            Échanger noeud1 et noeud2

        noeud1.taille += noeud2.taille
        noeud2.père = noeud1
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Graphes %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graphes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Plus courts chemins %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Plus courts chemins}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Floyd-Warshall %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Floyd-Warshall}

L'algorithme de Floyd-Warshall permet de calculer la longueur du plus court chemin entre chaque paire de noeuds d'un graphe \(G\) orienté et pondéré avec une complexité en \(\Theta(N^3)\). Les pondérations peuvent éventuellement être négatives, mais il ne doit pas exister de cycle négatif dans \(G\).

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/graphs/algorithms/floyd-warshall.hpp}{Implémentation}
\begin{lstlisting}
On initialise dist comme étant la matrice d'adjacence du graphe
Pour chaque noeud p:
  Pour chaque noeud d:
    Pour chaque noeud f:
      dist[d][f] = min(
        dist[d][p] + dist[p][f],
        dist[d][f]
      )
\end{lstlisting}

\begin{proof}
La correction de l'algorithme est assurée par l'invariant de boucle suivant, vérifié au début de chaque itération de la boucle principale : pour toute paire de noeuds d'indices respectifs \(d\) et \(f\), \(dist[d][f]\) est la longueur du plus court chemin du noeud d'indice \(d\) vers le noeud d'indice \(f\) n'utilisant comme noeuds intermédiaires que des noeuds d'indice dans \( [\![0, p-1]\!] \).
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Arbre du DFS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Arbre du DFS}
Il est possible de représenter un graphe orienté en mettant en avant les différentes propriétés de ses arcs pouvant être rencontrées lors d'un parcours en profondeur, ce qui peut par exemple aider à adapter l'algorithme du DFS à différents problèmes.
Pour cela, on effectue un parcours en profondeur du graphe, puis on représente le graphe selon l'arbre des appels de la fonction récursive.

\begin{figure}[h]
  \label{arbre-dfs}
  \centering
  \caption{Arbre du DFS}
  \vspace{2mm}
  \begin{tikzpicture}[scale=1.4]
    \node[node] (0) at (1,3) {};
    \node[node] (1) at (0,2) {};
    \node[node] (2) at (2,2) {};
    \node[node] (3) at (1,1) {};
    \node[node] (4) at (3,1) {};
    \node[node] (5) at (0,0) {};
    \node[node] (6) at (1,0) {};
    \node[node] (7) at (2,0) {};

    \draw[edge, ->] (0) to (1);
    \draw[edge, ->] (0) to (2);
    \draw[edge, ->] (2) to (3);
    \draw[edge, ->] (2) to (4);
    \draw[edge, ->] (3) to (5);
    \draw[edge, ->] (3) to (6);
    \draw[edge, ->] (3) to (7);

    \draw[edge, ->, red] (5) to [bend left] (2);
    \draw[edge, ->, green] (0) to [bend left] (4);
    \draw[edge, ->, blue] (4) to (3);
    \draw[edge, ->, blue] (4) to (7);
  \end{tikzpicture}
\end{figure}

Les arcs peuvent être classés en quatre catégories :
\begin{itemize}
  \item[\LARGE\textbf\textrightarrow] les \textit{arcs de découverte} pointent vers un noeud n'ayant pas encore été parcouru
  \item[\color{red} \LARGE\textbf\textrightarrow] les \textit{arcs arrières} pointent vers un noeud en cours de parcours
  \item[\color{green} \LARGE\textbf\textrightarrow] les \textit{arcs avants} pointent vers un noeud parcouru qui est un descendant du noeud actuel dans l'arbre d'appels
  \item[\color{blue} \LARGE\textbf\textrightarrow] les \textit{arcs transverses} pointent vers un noeud parcouru qui n'est pas un descendant du noeud actuel dans l'arbre d'appels
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Composantes fortement connexes %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Composantes fortement connexes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Algorithme de Kosaraju  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Algorithme de Kosaraju}
L'algorithme de Kosaraju permet de calculer les composantes fortement connexes d'un graphe orienté. Pour cela, il effectue successivement deux DFS. Le premier permet de trouver un parcours suffixe du graphe, c'est-à-dire un parcours suffixe de l'arbre des appels du DFS. Le deuxième est effectué sur le graphe transposé \(G^\top\) (graphe obtenu en inversant les arcs de \(G\)), en découvrant les noeuds dans l'ordre inverse du parcours suffixe. Il permet de déterminer les composantes fortement connexes du graphe.

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/graphs/algorithms/kosaraju.hpp}{Implémentation}
\begin{lstlisting}
Trouver un parcours suffixe du graphe
Pour chaque noeud v dans l'ordre inverse du parcours suffixe :
    Si v n'a pas encore été visité :
        Trouver l'ensemble des noeuds non-visités ayant accès à v
        Cet ensemble est la composante fortement connexe contenant v
        Marquer tous ses noeuds comme visités
\end{lstlisting}

\begin{proof}
  Montrons que l'ordre de parcours obtenu avec le premier DFS permet effectivement de trouver les composantes fortement connexes lors du deuxième DFS. Soit \(v\) un noeud sur lequel débute un parcours du deuxième DFS.
  \begin{itemize}
    \item Soit \(u\) un noeud de la composante fortement connexe à laquelle \(v\) appartient. Il existe un chemin de \(v\) vers \(u\) dans \(G^\top\). De plus, \(v\) est le premier noeud de sa composante fortement connexe à être rencontré, donc aucun des noeuds permettant de se rendre de \(v\) vers \(u\) n'a été initialement visité. Ainsi, \(u\) sera détecté lors du parcours.
    \item Soit \(u\) un noeud parcouru lors de l'appel du deuxième DFS depuis le noeud \(v\). Montrons que \(u\) appartient à la composante fortement connexe contenant \(v\).
      \begin{itemize}
        \item Il existe un chemin de \(v\) vers \(u\) dans \(G^\top\), donc il existe un chemin de \(u\) vers \(v\) dans \(G\).
        \item On suppose qu'il n'existe pas de chemin de \(v\) vers \(u\) dans \(G\). Le point précédent assure que \(v\) apparaît avant \(u\) dans le parcours suffixe de \(G\), donc que \(u\) a déjà été parcouru lorsque le parcours de \(v\) commence. Cela est absurde car \(u\) devrait être parcouru à nouveau lors de l'exploration depuis \(v\).
      \end{itemize}
  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Algorithme de Tarjan  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Algorithme de Tarjan}
L'algorithme de Tarjan permet de calculer les composantes fortement connexes d'un graphe orienté \(G=(V,E)\). Il effectue un parcours en profondeur du graphe, on utilisera donc la représentation graphique décrite précédemment qui est adaptée à cette situation. \\
On définit tout d'abord la racine d'une composante fortement connexe comme étant le premier noeud de la composante rencontré lors du parcours du graphe. Elles sont représentés en jaune sur le schéma. On remarque qu'une composante fortement connexe est un sous-arbre de l'arbre des appels du DFS enraciné sur la racine de la composante, privé des éventuels sous-arbres correspondant à d'autres composantes. Pour trouver les composantes fortement connexes, il suffit donc de trouver l'ensemble de leurs racines. \\
On effectue un DFS sur le graphe, en maintenant à jour :
\begin{itemize}
  \item Des identifiants pour chacun des noeuds : ils sont données par ordre croissant au fur et à mesure du parcours
  \item Une pile contenant les noeuds dont la composante n'a pas encore été parcourue complètement, ajoutés dans leur ordre de parcours
  \item L'état de chaque noeud, parmi les états suivants :
    \begin{itemize}
      \item À visiter : le noeud est encore inconnu
      \item Dans la pile : le noeud a été découvert, mais sa composante fortement connexe n'est pas encore complètement connue
      \item Visité : le parcours du noeud est terminé, et sa composante fortement connexe est complètement connue
    \end{itemize}
\end{itemize}
La fonction \lstinline|parcourir| renvoie le plus petit identifiant d'un noeud présent dans la pile et accessible directement depuis le sous-arbre enraciné sur le noeud d'appel, ou éventuellement \(+\infty\) si aucun noeud ne convient.

\begin{figure}[h]
  \label{algorithme-tarjan}
  \centering
  \caption{Exemple}
  \vspace{2mm}
  \begin{tikzpicture}[scale=1.6]
    \node[node, fill=yellow] (01) at (1,4) {1};
    \node[node, fill=yellow] (02) at (0,3) {2};
    \node[node] (03) at (0,2) {3};
    \node[node, fill=yellow] (04) at (1,3) {4};
    \node[node] (05) at (1,2) {5};
    \node[node] (06) at (1,1) {6};
    \node[node] (07) at (1,0) {7};
    \node[node] (08) at (2,2) {8};
    \node[node] (09) at (2,1) {9};
    \node[node] (10) at (2,3) {10};
    \node[node] (11) at (3,2) {11};

    \foreach \u / \v in {01/02, 01/04, 01/10, 02/03, 04/05, 05/06, 06/07, 04/08, 08/09, 10/11}
      \draw[edge, ->] (\u) to (\v);

    \draw[edge, ->, red] (03) to [bend left] (02);
    \draw[edge, ->, red] (07) to [bend left] (05);
    \draw[edge, ->, red] (06) to [bend right] (04);
    \draw[edge, ->, red] (11) to [bend left] (01);
    \draw[edge, ->, green] (01) to [bend right] (05);
    \draw[edge, ->, blue] (05) to (03);
    \draw[edge, ->, blue] (09) to (07);
  \end{tikzpicture}
\end{figure}

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/graphs/algorithms/tarjan.hpp}{Implémentation}
\begin{lstlisting}
Fonction parcourir (noeud):
    Donner un identifiant au noeud actuel
    Ajouter le noeud à la pile et mettre à jour son état

    idMinAccessible = idNoeud

    Pour chaque voisin:
        Si le voisin est dans la pile:
            idMinAccessible = min(idVoisin, idMinAccessible)
        Si le voisin n'a pas encore été visité:
            idMinAccessible = min(parcourir(voisin), idMinAccessible)

    Si idMinAccessible == idNoeud:
        La composante fortement connexe du noeud est composée des noeuds
          de la pile à partir du noeud actuel
        Enlever ces noeuds de la pile, et les marquer comme visités
        Renvoyer +oo

    Renvoyer idMinAccessible

Pour chaque noeud du graphe:
    Si le noeud est inconnu:
        Appeler la fonction parcourir sur ce noeud
\end{lstlisting}

Montrons que la fonction parcourir a le comportement attendu. On suppose que, lors d'un appel à la fonction parcourir, la boucle sur tous les voisins vient de se terminer.
\begin{itemize}
  \item Si idMinAccessible vaut l'identifiant du noeud, alors il est impossible de sortir du sous-arbre depuis celui-ci, sauf éventuellement vers une composante fortement connexe déjà complète. Le noeud est donc une racine, et la composante fortement connexe correspondante est composée de l'ensemble des noeuds au-dessus du noeud actuel dans la pile. On ajoute la composante à celles déjà détectées, et on continue l'exploration.
  \item On suppose à présent que idMinAccessible est strictement inférieur à l'identifiant du noeud. Le noeud correspondant appartient à une composante fortement connexe dont la racine est toujours en cours de visite (sinon, la composante aurait été trouvée). C'est donc un noeud ascendant du noeud actuel, et il est accessible depuis celui-ci. Ainsi, le noeud actuel n'est pas une racine. On renvoie la valeur demandée et on continue le parcours.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Arbre couvrant minimal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Arbre couvrant minimal}
Soit \(G=(V,E)\) un graphe pondéré non-orienté connexe. Un \textit{arbre couvrant} de \(G\) est un arbre inclus dans \(G\) contenant tous les noeuds de \(G\). On définit le \textit{poids} d'un arbre couvrant comme étant la somme des pondérations de ses arêtes. Un \textit{arbre couvrant minimal} est alors un arbre couvrant de poids minimal.

\begin{figure}[h]
  \label{arbre-couvrant-minimal}
  \centering
  \caption{Arbre couvrant minimal}
  \vspace{2mm}

  \begin{tikzpicture}[scale=2]
    \foreach \i / \x / \y in {0/0/1, 1/1/1, 2/0/0, 3/1/0, 4/2/0, 5/0.5/-1, 6/0/-2}
      \node[node] (\i) at (\x,\y) {\i};

    \foreach \u / \v / \p in {0/1/3, 2/3/5, 3/5/4, 4/5/5, 1/3/5}
      \draw[edge] (\u) -- (\v) node [midway, fill=white] {\p};

    \foreach \u / \v  / \p in {0/2/2, 1/4/3, 2/5/2, 5/6/9}
      \draw[edge, red!80] (\u) -- (\v) node [midway, fill=white] {\p};
    \draw[edge, red!80] (0) -- (3) node [near start, fill=white] {3};
    \draw[edge, red!80] (2) -- (1) node [near end, fill=white] {1};
  \end{tikzpicture}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Algorithme de Kruskal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Algorithme de Kruskal}
L'algorithme de Kruskal est un algorithme glouton permettant de déterminer un arbre couvrant minimal d'un graphe avec une complexité temporelle en \(\Theta\left(|E|\log(|E|)\right)\).
\begin{lstlisting}
Initialiser un union-find sur l'ensemble des noeuds du graphe
Créer un arbre vide
Pour chaque arête par pondération croissante :
    Si l'arête permet de relier deux noeuds non-connectés :
        Ajouter l'arête à l'arbre
        Fusionner les noeuds dans l'union-find
        Si l'arbre est couvrant :
            Renvoyer cet arbre
\end{lstlisting}

\begin{proof}
  L'algorithme renvoie bien un arbre couvrant de \(G\). Pour montrer qu'il est de poids minimal, on considère l'invariant suivant, vérifié au début de chaque itération de la boucle principale : il existe \(\widetilde{A}\) un arbre couvrant minimal de \(G\) contenant toutes les arêtes de l'arbre \(A\) construit par l'algorithme. Au début de l'exécution, \(A\) ne contient aucune arête, donc l'invariant est vérifié. Lorsqu'une arête \(a\) est ajoutée à \(A\) :
  \begin{itemize}
    \item Si \(a\) appartient déjà à \(\widetilde{A}\), l'invariant reste vérifié.
    \item On suppose que l'arête \(a\) n'appartient pas à \(\widetilde{A}\), et on note \((u,v)\) les noeuds qu'elle relie. \(\widetilde{A}\) est un arbre, donc il existe un chemin \(C\) de \(u\) vers \(v\) dans \(\widetilde{A}\). L'arête \(a\) doit être ajoutée à \(A\), donc il n'existe pas de chemin de \(u\) vers \(v\) dans \(A\). Ainsi, il existe une arête \(a'\) de \(C\) n'appartenant pas à \(A\), on note \(u'\) et \(v'\) les noeuds qu'elle relie. On suppose cette arête de pondération strictement inférieure à celle de \(a\). L'ordre de parcours des arêtes assure qu'elle a été parcourue précédemment, sans avoir été ajoutée à \(A\). Il donc un chemin de \(u'\) vers \(v'\) dans \(A\). Or, les arêtes de \(A\) appartiennent à \(\widetilde{A}\), donc il existe un chemin de \(u'\) vers \(v'\) dans \(\widetilde{A}\) n'utilisant pas l'arête \(a'\), ce qui est absurde car \(a'\) appartient à l'arbre \(\widetilde{A}\). Ainsi, \(a'\) est de pondération supérieure ou égale à celle de \(a\). En remplaçant \(a'\) par \(a\) dans \(\widetilde{A}\), on obtient un arbre couvrant minimal de \(G\) auquel toutes les arêtes de \(A\) appartiennent : l'invariant est donc vérifié.
  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Flots %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{Flots}
    \subsubsection{Définitions}

Soit \(G=(V,E)\) un graphe orienté et \((s,p)\) deux sommets distincts de \(V\) que l'on appellera respectivement \textit{source} et \textit{puits}. On associe à chaque arc \(e \in E\) un réel positif représentant sa capacité. Pour tout \((u,v) \in V^2\), on notera \(c(u,v)\) la somme des capacités des arcs de \(u\) vers \(v\).

\begin{definition}
  \(F = (G,c,s,p)\) constitue un réseau de flot.
\end{definition}

\begin{definition}
  Un flot \(f\) est une application de \(V^2\) dans \(\mathbb{R}\) telle que :
  \begin{itemize}
    \item Pour tout \((u,v) \in V^2\), \(f(u,v) \leq c(u,v)\)
    \item Pour tout \((u,v) \in V^2\), \(f(u,v) = -f(v,u)\)
    \item Pour tout \(u \in V \setminus \{s,p\}\), \(\sum\limits_{v \in V} f(u,v) = 0\)
    \item \(\sum\limits_{v \in V} f(s,v) \geq 0\) et \(\sum\limits_{v \in V} f(p,v) \leq 0\)
  \end{itemize}
\end{definition}

\begin{definition}
  La valeur d'un flot \(f\) est \(|f| = \sum\limits_{v \in V} f(s,v)\).
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Capacités résiduelles %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Capacités résiduelles}

Pour tout \((u,v) \in V^2\), on notera \(c_f(u,v) = c(u,v) - f(u,v)\) la capacité résiduelle de \(u\) vers \(v\). Cela correspond à la capacité disponible de \(u\) vers \(v\) après l'application du flot \(f\). Le réseau résiduel correspondant à \((F,f)\) est obtenu en remplaçant dans \(F\) les capacités des arcs par leurs capacités résiduelles.

\begin{definition}
  Un chemin augmentant est un chemin de \(s\) vers \(p\) sur lequel toutes les capacités résiduelles sont strictement positives.
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Algorithme d'Edmonds-Karp %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Algorithme d'Edmonds-Karp}
L'algorithme d'Edmonds-Karp permet de calculer le flot maximal pouvant traverser un réseau avec une complexité temporelle en \(O(|V| |E|^2)\). Sa complexité est également en \(O(S)\) où \(S\) est la somme des capacités des arcs du graphe. Pour cela, il commence par considérer un flot nul qu'il améliore ensuite tant que possible ; le flot finalement obtenu étant de valeur maximale.

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/graphs/algorithms/edmonds-karp.hpp}{Implémentation}
\begin{lstlisting}
Initialiser f comme étant un flot nul
Créer le réseau résiduel correspondant à f
Tant qu'il existe un chemin augmentant dans le réseau résiduel :
    Utiliser ce chemin pour améliorer le flot
    Mettre à jour le graphe résiduel
\end{lstlisting}

La recherche d'un chemin augmentant est effectuée à l'aide d'un BFS dans le graphe résiduel.

\begin{proof} \leavevmode
  \begin{itemize}
    \item Terminaison : \(|f|\) croît strictement à chaque itération de la boucle principale, et la valeur d'un flot est majorée par la somme de la capacité des arcs. Ainsi, \textbf{lorsque les capacités sont des entiers}, l'algorithme termine. Cet argument prouve également la complexité en \(O(S)\).
    \item Correction : Lorsque l'algorithme termine, il n'existe plus de chemin augmentant, le flot obtenu est donc de valeur maximale.
    % \item Complexité : la recherche d'un chemin augmentant est effectuée à l'aide d'un BFS, sa complexité temporelle est donc en \(O(|E|)\).
  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Théorème Flot-Max / Coupe-Min %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsubsection{Théorème Flot-Max / Coupe-Min}

\begin{figure}[ht]
  \centering
  \begin{minipage}{.5\textwidth}
    \centering
    \caption{Graphe \(G\), flot max}
    \vspace{2mm}

    \begin{tikzpicture}[scale=0.03]
      \node[node][fill=green!80] (00) at (238.2, 119)     {p};
      \node[node] (01) at (164.8, 103.4)   {};
      \node[node] (02) at (182.1, 169.7)   {};
      \node[node] (03) at (286.2, 167.5)   {};
      \node[node] (04) at (211.1, 220)     {};
      \node[node] (05) at (282.5, 238.1)   {};
      \node[node] (06) at (133.5, 215.9)   {};
      \node[node][fill=orange!80] (07) at (165.5, 279.4)   {s};
      \node[node] (08) at (235.7, 291.2)   {};

      \draw[selected edge, <-] (00) -- (01);
      \draw[edge]              (00) -- (02);
      \draw[selected edge, <-] (00) -- (03);
      \draw[selected edge, <-] (01) -- (02);
      \draw[selected edge, <-] (02) -- (04);
      \draw[edge]              (03) -- (04);
      \draw[selected edge, <-] (03) -- (05);
      \draw[edge]              (04) -- (06);
      \draw[selected edge, <-] (04) -> (07);
      \draw[edge]              (04) -- (08);
      \draw[selected edge, <-] (05) -- (08);
      \draw[edge]              (06) -- (07);
      \draw[selected edge, ->] (07) -- (08);
    \end{tikzpicture}
  \end{minipage}%
  \begin{minipage}{.5\textwidth}
    \centering
    \caption{Graphe résiduel \(G'\)}
    \vspace{2mm}

    \begin{tikzpicture}[scale=0.03]
      \node[node][fill=green!80] (00) at (238.2, 119)     {p};
      \node[node][fill=green!60] (01) at (164.8, 103.4)   {};
      \node[node][fill=green!60] (02) at (182.1, 169.7)   {};
      \node[node][fill=orange!60] (03) at (286.2, 167.5)   {};
      \node[node][fill=orange!60] (04) at (211.1, 220)     {};
      \node[node][fill=orange!60] (05) at (282.5, 238.1)   {};
      \node[node][fill=orange!60] (06) at (133.5, 215.9)   {};
      \node[node][fill=orange!80] (07) at (165.5, 279.4)   {s};
      \node[node][fill=orange!60] (08) at (235.7, 291.2)   {};

      \draw[edge, ->] (00) -- (01) node [midway, fill=white] {2};;
      \draw[edge]              (00) -- (02);
      \draw[edge, ->] (00) -- (03) node [midway, fill=white] {2};;
      \draw[edge, ->] (01) -- (02) node [midway, fill=white] {2};;
      \draw[edge, ->] (02) -- (04) node [midway, fill=white] {2};;
      \draw[edge]              (03) -- (04);
      \draw[edge, ->] (03) -- (05) node [midway, fill=white] {2};;
      \draw[edge]              (04) -- (06);
      \draw[edge, ->] (04) -> (07) node [midway, fill=white] {2};;
      \draw[edge]              (04) -- (08);
      \draw[edge, ->] (05) -- (08) node [midway, fill=white] {2};;
      \draw[edge]              (06) -- (07);
      \draw[edge, <-] (07) -- (08) node [midway, fill=white] {2};;
    \end{tikzpicture}
  \end{minipage}
\end{figure}

\begin{theorem}
Soit \(G=(V,E)\) un graphe orienté pondéré, et \(s\) et \(p\) deux sommets de \(G\). La valeur maximale d'un flot de \(s\) vers \(p\) est égale à la valeur minimale d'une coupe entre \(s\) et \(p\).
\end{theorem}
\begin{proof}\leavevmode
  \begin{itemize}
    \item Le flot max doit être réparti parmi les arcs de toute coupe, donc \( \left| FlotMax \right| \leq \left| CoupeMin \right| \)
    \item On note \(G'\) le graphe résiduel correspondant à un flot max de \(G\), \(A\) l'ensemble des noeuds accessibles depuis \(S\) dans \(G'\) et \(B\) l'ensemble des noeuds n'appartenant pas à \(A\). Il n'existe pas de chemin améliorant, donc \(p \in B\). On considère \(\mathcal{C}\) l'ensemble des arcs de \(G\) partant d'un noeud de \(A\) vers un noeud de \(B\).
    \begin{itemize}
        \item \(s \in A\), \(p \in B\) et il n'existe pas d'arc hors de \(\mathcal{C}\) d'un noeud de \(A\) vers un noeud de \(B\), donc \(\mathcal{C}\) est une coupe.
        \item Dans le graphe résiduel \(G'\), il n'existe pas d'arc de \(A\) vers \(B\), donc les arcs de \(B\) vers \(A\) ne sont pas utilisés et ceux de \(A\) vers \(B\) sont saturés. Ainsi, la somme des capacités des arcs de \(A\) vers \(B\) est égale au flot max. Or, cette somme est égale à la somme des pondérations des arcs de \(\mathcal{C}\), donc \( \left| CoupeMin \right| \leq \left| FlotMax \right| \)
    \end{itemize}
  \end{itemize}
  Finalement, \( \left| CoupeMin \right| = \left| FlotMax \right| \)
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Couplages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Couplages}
Soit \(G=(V,E)\) un graphe biparti dont on note \((X,Y)\) une partition des sommets adaptée, c'est-à-dire telle que toute arête relie un noeud de \(X\) avec un noeud de \(Y\). Un \textit{couplage} \(C\) de \(G\) est une partie de \(E\) telle que tout noeud ne soit relié qu'à au plus une arête de \(C\). Un couplage est dit \textit{maximum} si et seulement si il est de cardinal maximal. Pour la suite, les arêtes d'un graphe appartenant à un couplage seront représentées en rouge et celles n'y appartenant pas seront représentées en noir.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Chemins d'augmentation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \subsubsection{Chemins d'augmentation}

\begin{definition}
  Un chemin d'augmentation d'un graphe biparti \(G=(V,E)\) muni d'un couplage \(C\) est une suite finie \(v = (v_0, ..., v_{p-1})\) de sommets de \(V\) telle que \(v_0 \in X\), \(v_{p-1} \in Y\), les sommets \(v_0\) et \(v_{p-1}\) ne soient reliés à aucune arête de \(C\) et :
  \[
    \forall i \in [\![0,p-2]\!], \{v_i,v_{i+1}\} \in
      \left\{
        \begin{array}{ll}
          E \setminus C & \text{ si i est pair} \\
          C & \text{ si i est impair}
        \end{array}
      \right.
  \]
\end{definition}

\begin{theorem}
  Un couplage \(C\) d'un graphe biparti \(G=(V,E)\) est maximum si et seulement si il n'existe pas de chemin d'augmentation pour ce couplage.
\end{theorem}
\begin{proof}\leavevmode
  \begin{itemize}
    \item On suppose qu'il existe un chemin d'augmentation \(v = (v_0, ..., v_{p-1})\). La différence symétrique de \(C\) et de \(\{ \{v_i,v_{i+1}\}, i \in [\![0,p-2]\!] \}\) est alors un couplage de cardinal \(|C|+1\). Ainsi, s'il existe un chemin d'augmentation, le couplage n'est pas maximum.

    \item
      On suppose réciproquement qu'il n'existe pas de chemin d'augmentation. Il existe \(C_0\) un couplage maximum de \(G\). On note \(D\) la différence symétrique de \(C\) et de \(C_0\). \(C\) et \(C_0\) sont des couplages, donc chaque sommet de \(G\) est adjacent à au plus deux arêtes de \(D\). Ainsi, les arêtes de \(D\) forment des \textit{cycles} ou des \textit{chaînes} d'arêtes, par exemple :

      \begin{figure}[ht]
        \centering
        \begin{minipage}{.5\textwidth}
          \centering
          \caption{Cycle}
          \vspace{2mm}
          \begin{tikzpicture}[scale=1.3]
            \node[node] (0) at (0,0)   {};
            \node[node] (1) at (1,0)   {};
            \node[node] (2) at (0,1)   {};
            \node[node] (3) at (1,1)   {};
            \draw[edge, red] (0) -- (1);
            \draw[edge, red] (1) -- (2);
            \draw[edge, red] (2) -- (3);
            \draw[edge, red] (3) -- (0);
          \end{tikzpicture}
        \end{minipage}%
        \begin{minipage}{.5\textwidth}
          \centering
          \caption{Chaîne}
          \vspace{2mm}
          \begin{tikzpicture}[scale=1.3]
            \node[node] (0) at (0,0)   {};
            \node[node] (1) at (1,0)  {};
            \node[node] (2) at (0,1)  {};
            \node[node] (3) at (1,1)   {};
            \draw[edge, red] (0) -- (1);
            \draw[edge, red] (2) -- (3);
            \draw[edge, red] (3) -- (0);
          \end{tikzpicture}
        \end{minipage}
      \end{figure}

      On suppose qu'il existe une chaîne composée d'un nombre impair d'arêtes. Si les arêtes à ses extrémités sont dans \(C\), elle permet d'obtenir un chemin d'augmentation pour \(C_0\), et si les arêtes à ses extrémités sont dans \(C_0\), elle permet d'obtenir un chemin d'augmentation pour \(C\). Or, cela est absurde car il n'existe de chemin d'augmentation ni pour \(C\) (par hypothèse), ni pour \(C_0\) (il est maximum). Toutes les chaînes sont ainsi composées d'un nombre pair d'arêtes. Finalement, \(|C|=|C_0|\), donc \(C\) est maximum.

  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Recherche d'un couplage maximum %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \subsubsection{Recherche d'un couplage maximum}
Soit \(G=(V,E)\) un graphe biparti. Pour construire un couplage maximum de \(G\), on peut améliorer tant que possible un couplage initialement vide en trouvant et utilisant des chemins d'augmentation. L'algorithme décrit a une complexité en \(O(|V||E|)\).

\begin{lstlisting}
Créer un couplage vide C
Tant qu'il existe un chemin d'augmentation :
    L'utiliser pour augmenter de un la taille de C
\end{lstlisting}

\begin{proof}\leavevmode
  \begin{itemize}
    \item L'entier \(|C|\) est incrémenté à chaque itération de la boucle principale. Or, \(|C| \leq \frac{|V|}{2}\), donc l'algorithme termine, et la boucle principale est exécutée au plus \(|V|\) fois.
    \item À la fin de l'exécution de l'algorithme, il n'existe plus de chemin d'augmentation pour \((G,C)\) : le théorème précédent assure donc que \(C\) est maximum. Ainsi, l'algorithme renvoie un couplage maximum.
    \item Chaque itération de la boucle principale nécessite un parcours du graphe pour rechercher un chemin d'augmentation et un parcours des arêtes constituant le chemin d'augmentation. Ces opérations s'effectuent en \(O(|E|)\). Finalement, la complexité temporelle de l'algorithme est en \(O(|V||E|)\).
  \end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Géométrie %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \section{Géométrie}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Enveloppe convexe %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Enveloppe convexe}

On considère un ensemble \(A\) de \(n\) points du plan de coordonnées \((x_i,y_i)\) dont on cherche à calculer l'enveloppe convexe. Pour cela, il suffit de calculer d'abord la partie supérieure de l'enveloppe, puis sa partie inférieure. Le calcul de la partie inférieure pourra s'effectuer de manière similaire à celui de la partie supérieure, on ne décrira donc que le calcul de la partie supérieure. On effectue un balayage des points de \(A\) par abscisses décroissantes, en maintenant sur une pile l'ensemble des points de \(A\) parcourus et appartenant à la frontière de l'enveloppe convexe actuelle. À chaque tour de boucle, on enlève de la pile les points n'appartenant plus à l'enveloppe convexe, puis on ajoute le point actuel.

\noindent\href{https://github.com/AdrienVannson/algo-lib/blob/master/include/geometry/convex-hull.hpp}{Implémentation}
\begin{lstlisting}
Créer une pile de points vide
Pour chaque point de A par abscisses décroissantes :
    Tant que le point en haut de la pile peut être supprimé :
        Le supprimer
    Ajouter le point actuel à la pile
\end{lstlisting}

L'algorithme décrit a une complexité temporelle en \(O(n \log(n) )\) car il nécessite un tri des points.



\end{document}
